/*
 * API микросервиса авторизации
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ru.softlab.efr.services.auth;

import ru.softlab.efr.services.auth.exchange.model.ChangeLoginData;
import ru.softlab.efr.services.auth.exchange.model.ChangePasswordData;
import ru.softlab.efr.services.auth.exchange.model.ChangePasswordRs;
import ru.softlab.efr.services.auth.exchange.model.CreateEmployeeRs;
import ru.softlab.efr.services.auth.exchange.model.CreateOrUpdateEmployeeRq;
import ru.softlab.efr.services.auth.exchange.model.EmploeeDataWithOrgUnits;
import ru.softlab.efr.services.auth.exchange.model.EmployeeDataForList;
import ru.softlab.efr.services.auth.exchange.model.ErrorData;
import ru.softlab.efr.services.auth.exchange.model.FilterEmployeesRq;
import ru.softlab.efr.services.auth.exchange.model.GetEmployeeRs;
import ru.softlab.efr.services.auth.exchange.model.LockEmployeeRq;
import ru.softlab.efr.services.auth.exchange.model.PrivateChangeLoginData;
import ru.softlab.efr.services.auth.exchange.model.SetPasswordData;
import ru.softlab.efr.services.auth.exchange.model.UpdateListStatus;
import ru.softlab.efr.services.auth.exchange.model.UpdateUserRq;

import ru.softlab.efr.infrastructure.transport.client.*;
import ru.softlab.efr.common.utilities.rest.*;
import ru.softlab.efr.common.utilities.rest.client.*;
import ru.softlab.efr.common.utilities.rest.converters.DateParser;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import ru.softlab.efr.infrastructure.transport.client.impl.JmsUriBuilder;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.util.*;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Содержит методы для взаимодействия с приложением auth-service
 **/
@Component
public class EmployeesClient {
    private static final String REQUIRED_PARAM_ERROR = "Не указан обязательный параметр '%s' при вызове %s";
    private String applicationName;
    private static final String STATUS_CODE_TEMPLATE = "status code: [%s]";

    private final MicroServiceTemplate microServiceTemplate;

    /**
     * Возвращяет экземпляр класса
     * @param microServiceTemplate - объект, реализующий интерфейс {@link MicroServiceTemplate}
     */
    public EmployeesClient(MicroServiceTemplate microServiceTemplate) {
        this.microServiceTemplate = microServiceTemplate;
        this.applicationName = "auth-service";
    }


    /**
     * Запрос на изменение логина пользователя
     * POST /auth/v1/changeLogin
     *
     * @param body Данные для изменения логина пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void changeLogin(ChangeLoginData body, long timeout) throws RestClientException {
        return changeLogin(body).get(timeout);
    }

    /**
     * Запрос на изменение логина пользователя асинхронно
     * POST /auth/v1/changeLogin
     *
     * @param body Данные для изменения логина пользователя (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> changeLogin(ChangeLoginData body) throws RestClientException {
        return new ClientRestResult<>(changeLoginInternal(body), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> changeLoginInternal(ChangeLoginData body) throws RestClientException {
        if (body == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "body", "changeLogin"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/changeLogin"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(body);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос на изменение логина пользователя
     * POST /auth/v1/private/changeLogin
     *
     * @param body Данные для изменения логина пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void changeLoginWithOutPermission(PrivateChangeLoginData body, long timeout) throws RestClientException {
        return changeLoginWithOutPermission(body).get(timeout);
    }

    /**
     * Запрос на изменение логина пользователя асинхронно
     * POST /auth/v1/private/changeLogin
     *
     * @param body Данные для изменения логина пользователя (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> changeLoginWithOutPermission(PrivateChangeLoginData body) throws RestClientException {
        return new ClientRestResult<>(changeLoginWithOutPermissionInternal(body), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> changeLoginWithOutPermissionInternal(PrivateChangeLoginData body) throws RestClientException {
        if (body == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "body", "changeLoginWithOutPermission"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/changeLogin"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(body);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос на изменение пароля пользователя
     * POST /auth/v1/changePassword
     *
     * @param changePasswordRequest Данные для изменения пароля пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void changePassword(ChangePasswordData changePasswordRequest, long timeout) throws RestClientException {
        return changePassword(changePasswordRequest).get(timeout);
    }

    /**
     * Запрос на изменение пароля пользователя асинхронно
     * POST /auth/v1/changePassword
     *
     * @param changePasswordRequest Данные для изменения пароля пользователя (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> changePassword(ChangePasswordData changePasswordRequest) throws RestClientException {
        return new ClientRestResult<>(changePasswordInternal(changePasswordRequest), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> changePasswordInternal(ChangePasswordData changePasswordRequest) throws RestClientException {
        if (changePasswordRequest == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "changePasswordRequest", "changePassword"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/changePassword"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(changePasswordRequest);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос на изменение пароля пользователя
     * POST /auth/v1/private/changePassword
     *
     * @param changePasswordRequest Данные для изменения пароля пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ChangePasswordRs changePasswordPrivate(ChangePasswordData changePasswordRequest, long timeout) throws RestClientException {
        return changePasswordPrivate(changePasswordRequest).get(timeout);
    }

    /**
     * Запрос на изменение пароля пользователя асинхронно
     * POST /auth/v1/private/changePassword
     *
     * @param changePasswordRequest Данные для изменения пароля пользователя (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ChangePasswordRs> changePasswordPrivate(ChangePasswordData changePasswordRequest) throws RestClientException {
        return new ClientRestResult<>(changePasswordPrivateInternal(changePasswordRequest), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ChangePasswordRs>> changePasswordPrivateInternal(ChangePasswordData changePasswordRequest) throws RestClientException {
        if (changePasswordRequest == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "changePasswordRequest", "changePasswordPrivate"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/changePassword"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(changePasswordRequest);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ChangePasswordRs>(){});
    }

    /**
     * Создание сотрудника
     * POST /auth/v1/employees
     *
     * @param createEmployeeRq данные сотрудника (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public CreateEmployeeRs createEmployee(CreateOrUpdateEmployeeRq createEmployeeRq, long timeout) throws RestClientException {
        return createEmployee(createEmployeeRq).get(timeout);
    }

    /**
     * Создание сотрудника асинхронно
     * POST /auth/v1/employees
     *
     * @param createEmployeeRq данные сотрудника (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<CreateEmployeeRs> createEmployee(CreateOrUpdateEmployeeRq createEmployeeRq) throws RestClientException {
        return new ClientRestResult<>(createEmployeeInternal(createEmployeeRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<CreateEmployeeRs>> createEmployeeInternal(CreateOrUpdateEmployeeRq createEmployeeRq) throws RestClientException {
        if (createEmployeeRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "createEmployeeRq", "createEmployee"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(createEmployeeRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<CreateEmployeeRs>(){});
    }

    /**
     * Создание сотрудника (private api)
     * POST /auth/v1/private/employee
     *
     * @param createEmployeeRq данные сотрудника (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public CreateEmployeeRs createEmployeeWithOutPermissions(CreateOrUpdateEmployeeRq createEmployeeRq, long timeout) throws RestClientException {
        return createEmployeeWithOutPermissions(createEmployeeRq).get(timeout);
    }

    /**
     * Создание сотрудника (private api) асинхронно
     * POST /auth/v1/private/employee
     *
     * @param createEmployeeRq данные сотрудника (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<CreateEmployeeRs> createEmployeeWithOutPermissions(CreateOrUpdateEmployeeRq createEmployeeRq) throws RestClientException {
        return new ClientRestResult<>(createEmployeeWithOutPermissionsInternal(createEmployeeRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<CreateEmployeeRs>> createEmployeeWithOutPermissionsInternal(CreateOrUpdateEmployeeRq createEmployeeRq) throws RestClientException {
        if (createEmployeeRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "createEmployeeRq", "createEmployeeWithOutPermissions"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/employee"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(createEmployeeRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<CreateEmployeeRs>(){});
    }

    /**
     * Запрос удаления сотрудника
     * DELETE /auth/v1/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void deleteEmployee(Long id, long timeout) throws RestClientException {
        return deleteEmployee(id).get(timeout);
    }

    /**
     * Запрос удаления сотрудника асинхронно
     * DELETE /auth/v1/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> deleteEmployee(Long id) throws RestClientException {
        return new ClientRestResult<>(deleteEmployeeInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> deleteEmployeeInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "deleteEmployee"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.DELETE, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос получения информации о сотруднике
     * GET /auth/v1/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public GetEmployeeRs getEmployeeById(Long id, long timeout) throws RestClientException {
        return getEmployeeById(id).get(timeout);
    }

    /**
     * Запрос получения информации о сотруднике асинхронно
     * GET /auth/v1/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<GetEmployeeRs> getEmployeeById(Long id) throws RestClientException {
        return new ClientRestResult<>(getEmployeeByIdInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<GetEmployeeRs>> getEmployeeByIdInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "getEmployeeById"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<GetEmployeeRs>(){});
    }

    /**
     * Запрос получения информации о сотруднике
     * GET /auth/v1/private/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public EmploeeDataWithOrgUnits getEmployeeByIdWithOutPermission(Long id, long timeout) throws RestClientException {
        return getEmployeeByIdWithOutPermission(id).get(timeout);
    }

    /**
     * Запрос получения информации о сотруднике асинхронно
     * GET /auth/v1/private/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<EmploeeDataWithOrgUnits> getEmployeeByIdWithOutPermission(Long id) throws RestClientException {
        return new ClientRestResult<>(getEmployeeByIdWithOutPermissionInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<EmploeeDataWithOrgUnits>> getEmployeeByIdWithOutPermissionInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "getEmployeeByIdWithOutPermission"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/employees/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<EmploeeDataWithOrgUnits>(){});
    }

    /**
     * Получить пользователя системы по логину (private api)
     * GET /auth/v1/private/employee
     *
     * @param login Логин пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public EmployeeDataForList getEmployeeByLoginWithOutPermissions(String login, long timeout) throws RestClientException {
        return getEmployeeByLoginWithOutPermissions(login).get(timeout);
    }

    /**
     * Получить пользователя системы по логину (private api) асинхронно
     * GET /auth/v1/private/employee
     *
     * @param login Логин пользователя (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<EmployeeDataForList> getEmployeeByLoginWithOutPermissions(String login) throws RestClientException {
        return new ClientRestResult<>(getEmployeeByLoginWithOutPermissionsInternal(login), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<EmployeeDataForList>> getEmployeeByLoginWithOutPermissionsInternal(String login) throws RestClientException {
        if (login == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "login", "getEmployeeByLoginWithOutPermissions"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/employee"));

        if (login != null)
            uriBuilder.param("login", login);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<EmployeeDataForList>(){});
    }

    /**
     * Получение списка учетных записей всех сотрудников. Список отсортирован по ФИО сотрудников.
     * PUT /auth/v1/employees
     *
     * @param filterData Тело запроса с данными фильтрации (optional)
     * @param hasFilter Признак фильтрации сотрудников (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public RestPageImpl<EmployeeDataForList> getEmployees(Pageable pageable, FilterEmployeesRq filterData, Boolean hasFilter, long timeout) throws RestClientException {
        return getEmployees(pageable, filterData, hasFilter).get(timeout);
    }

    /**
     * Получение списка учетных записей всех сотрудников. Список отсортирован по ФИО сотрудников. асинхронно
     * PUT /auth/v1/employees
     *
     * @param filterData Тело запроса с данными фильтрации (optional)
     * @param hasFilter Признак фильтрации сотрудников (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<RestPageImpl<EmployeeDataForList>> getEmployees(Pageable pageable, FilterEmployeesRq filterData, Boolean hasFilter) throws RestClientException {
        return new ClientRestResult<>(getEmployeesInternal(pageable, filterData, hasFilter), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<RestPageImpl<EmployeeDataForList>>> getEmployeesInternal(Pageable pageable, FilterEmployeesRq filterData, Boolean hasFilter) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees"));

        addPageableParams(uriBuilder, pageable);
        if (hasFilter != null)
            uriBuilder.param("hasFilter", hasFilter);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .body(filterData);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<RestPageImpl<EmployeeDataForList>>(){});
    }

    /**
     * Получение списка пользователей системы (private api)
     * GET /auth/v1/private/employees
     *
     * @param filterData Тело запроса с данными фильтрации (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public List<EmployeeDataForList> getEmployeesWithOutPermissions(FilterEmployeesRq filterData, long timeout) throws RestClientException {
        return getEmployeesWithOutPermissions(filterData).get(timeout);
    }

    /**
     * Получение списка пользователей системы (private api) асинхронно
     * GET /auth/v1/private/employees
     *
     * @param filterData Тело запроса с данными фильтрации (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<List<EmployeeDataForList>> getEmployeesWithOutPermissions(FilterEmployeesRq filterData) throws RestClientException {
        return new ClientRestResult<>(getEmployeesWithOutPermissionsInternal(filterData), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<List<EmployeeDataForList>>> getEmployeesWithOutPermissionsInternal(FilterEmployeesRq filterData) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/employees"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .body(filterData);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<List<EmployeeDataForList>>(){});
    }

    /**
     * Получение списка пользователей системы (private api)
     * GET /auth/v1/private/employees/all
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public List<EmployeeDataForList> getEmployeesWithOutPermissionsWithDeleted(long timeout) throws RestClientException {
        return getEmployeesWithOutPermissionsWithDeleted().get(timeout);
    }

    /**
     * Получение списка пользователей системы (private api) асинхронно
     * GET /auth/v1/private/employees/all
     *
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<List<EmployeeDataForList>> getEmployeesWithOutPermissionsWithDeleted() throws RestClientException {
        return new ClientRestResult<>(getEmployeesWithOutPermissionsWithDeletedInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<List<EmployeeDataForList>>> getEmployeesWithOutPermissionsWithDeletedInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/employees/all"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<List<EmployeeDataForList>>(){});
    }

    /**
     * Запрос блокировки пользователя
     * POST /auth/v1/employees/{id}/lock
     *
     * @param id Идентификатор сотрудника (required)
     * @param lockEmployeeRq Тело запроса блокировки пользователя (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void lockEmployee(Long id, LockEmployeeRq lockEmployeeRq, long timeout) throws RestClientException {
        return lockEmployee(id, lockEmployeeRq).get(timeout);
    }

    /**
     * Запрос блокировки пользователя асинхронно
     * POST /auth/v1/employees/{id}/lock
     *
     * @param id Идентификатор сотрудника (required)
     * @param lockEmployeeRq Тело запроса блокировки пользователя (optional)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> lockEmployee(Long id, LockEmployeeRq lockEmployeeRq) throws RestClientException {
        return new ClientRestResult<>(lockEmployeeInternal(id, lockEmployeeRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> lockEmployeeInternal(Long id, LockEmployeeRq lockEmployeeRq) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "lockEmployee"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/{id}/lock")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(lockEmployeeRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Установка технического пароля для клиента
     * GET /auth/v1/private/client/resetPassword/{id}
     *
     * @param id Идентификатор клиента. (required)
     * @param password Технический пароль (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void resetClientPasswordWithOutPermission(Long id, String password, long timeout) throws RestClientException {
        return resetClientPasswordWithOutPermission(id, password).get(timeout);
    }

    /**
     * Установка технического пароля для клиента асинхронно
     * GET /auth/v1/private/client/resetPassword/{id}
     *
     * @param id Идентификатор клиента. (required)
     * @param password Технический пароль (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> resetClientPasswordWithOutPermission(Long id, String password) throws RestClientException {
        return new ClientRestResult<>(resetClientPasswordWithOutPermissionInternal(id, password), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> resetClientPasswordWithOutPermissionInternal(Long id, String password) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "resetClientPasswordWithOutPermission"));
        if (password == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "password", "resetClientPasswordWithOutPermission"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/client/resetPassword/{id}")).variable("id", id);

        if (password != null)
            uriBuilder.param("password", password);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос на сброс пароля пользователя
     * GET /auth/v1/resetPassword/{id}
     *
     * @param id Идентификатор сотрудника. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void resetPassword(Long id, long timeout) throws RestClientException {
        return resetPassword(id).get(timeout);
    }

    /**
     * Запрос на сброс пароля пользователя асинхронно
     * GET /auth/v1/resetPassword/{id}
     *
     * @param id Идентификатор сотрудника. (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> resetPassword(Long id) throws RestClientException {
        return new ClientRestResult<>(resetPasswordInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> resetPasswordInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "resetPassword"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/resetPassword/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос на установку пользователю пароля
     * POST /auth/v1/private/setNewPassword/{userId}
     *
     * @param userId Идентификатор пользователя (required)
     * @param setPasswordRq Данные для изменения пароля (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void setPasswordWithOutPermission(Long userId, SetPasswordData setPasswordRq, long timeout) throws RestClientException {
        return setPasswordWithOutPermission(userId, setPasswordRq).get(timeout);
    }

    /**
     * Запрос на установку пользователю пароля асинхронно
     * POST /auth/v1/private/setNewPassword/{userId}
     *
     * @param userId Идентификатор пользователя (required)
     * @param setPasswordRq Данные для изменения пароля (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> setPasswordWithOutPermission(Long userId, SetPasswordData setPasswordRq) throws RestClientException {
        return new ClientRestResult<>(setPasswordWithOutPermissionInternal(userId, setPasswordRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> setPasswordWithOutPermissionInternal(Long userId, SetPasswordData setPasswordRq) throws RestClientException {
        if (userId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "userId", "setPasswordWithOutPermission"));
        if (setPasswordRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "setPasswordRq", "setPasswordWithOutPermission"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/setNewPassword/{userId}")).variable("userId", userId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(setPasswordRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Получить статус синхронизация списка учетных записей сотрудников с файлом
     * GET /auth/v1/employees/import/sync/status
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public UpdateListStatus statusSyncEmployeeList(long timeout) throws RestClientException {
        return statusSyncEmployeeList().get(timeout);
    }

    /**
     * Получить статус синхронизация списка учетных записей сотрудников с файлом асинхронно
     * GET /auth/v1/employees/import/sync/status
     *
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<UpdateListStatus> statusSyncEmployeeList() throws RestClientException {
        return new ClientRestResult<>(statusSyncEmployeeListInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<UpdateListStatus>> statusSyncEmployeeListInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/import/sync/status"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<UpdateListStatus>(){});
    }

    /**
     * Синхронизация списка учетных записей сотрудников с файлом
     * GET /auth/v1/employees/import/sync
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public UpdateListStatus syncEmployeeList(long timeout) throws RestClientException {
        return syncEmployeeList().get(timeout);
    }

    /**
     * Синхронизация списка учетных записей сотрудников с файлом асинхронно
     * GET /auth/v1/employees/import/sync
     *
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<UpdateListStatus> syncEmployeeList() throws RestClientException {
        return new ClientRestResult<>(syncEmployeeListInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<UpdateListStatus>> syncEmployeeListInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/import/sync"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<UpdateListStatus>(){});
    }

    /**
     * Запрос разблокировки пользователя
     * POST /auth/v1/employees/{id}/unlock
     *
     * @param id Идентификатор сотрудника (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void unlockEmployee(Long id, long timeout) throws RestClientException {
        return unlockEmployee(id).get(timeout);
    }

    /**
     * Запрос разблокировки пользователя асинхронно
     * POST /auth/v1/employees/{id}/unlock
     *
     * @param id Идентификатор сотрудника (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> unlockEmployee(Long id) throws RestClientException {
        return new ClientRestResult<>(unlockEmployeeInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> unlockEmployeeInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "unlockEmployee"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/{id}/unlock")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос обновления данных сотрудника
     * PUT /auth/v1/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param updateEmployeeRq Тело запроса обновления данных пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void updateEmployee(Long id, CreateOrUpdateEmployeeRq updateEmployeeRq, long timeout) throws RestClientException {
        return updateEmployee(id, updateEmployeeRq).get(timeout);
    }

    /**
     * Запрос обновления данных сотрудника асинхронно
     * PUT /auth/v1/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param updateEmployeeRq Тело запроса обновления данных пользователя (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> updateEmployee(Long id, CreateOrUpdateEmployeeRq updateEmployeeRq) throws RestClientException {
        return new ClientRestResult<>(updateEmployeeInternal(id, updateEmployeeRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> updateEmployeeInternal(Long id, CreateOrUpdateEmployeeRq updateEmployeeRq) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "updateEmployee"));
        if (updateEmployeeRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "updateEmployeeRq", "updateEmployee"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/employees/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .body(updateEmployeeRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос обновления данных сотрудника (private api)
     * PUT /auth/v1/private/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param updateEmployeeRq Тело запроса обновления данных пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void updateEmployeeWithOutPermissions(Long id, CreateOrUpdateEmployeeRq updateEmployeeRq, long timeout) throws RestClientException {
        return updateEmployeeWithOutPermissions(id, updateEmployeeRq).get(timeout);
    }

    /**
     * Запрос обновления данных сотрудника (private api) асинхронно
     * PUT /auth/v1/private/employees/{id}
     *
     * @param id Идентификатор сотрудника (required)
     * @param updateEmployeeRq Тело запроса обновления данных пользователя (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> updateEmployeeWithOutPermissions(Long id, CreateOrUpdateEmployeeRq updateEmployeeRq) throws RestClientException {
        return new ClientRestResult<>(updateEmployeeWithOutPermissionsInternal(id, updateEmployeeRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> updateEmployeeWithOutPermissionsInternal(Long id, CreateOrUpdateEmployeeRq updateEmployeeRq) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "updateEmployeeWithOutPermissions"));
        if (updateEmployeeRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "updateEmployeeRq", "updateEmployeeWithOutPermissions"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/employees/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .body(updateEmployeeRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Запрос обновления основных полей пользователя (private api)
     * POST /auth/v1/private/user/{id}/update
     *
     * @param id Идентификатор пользователя (required)
     * @param updateUserRq Тело запроса обновления данных пользователя (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void updateUserWithOutPermissions(Long id, UpdateUserRq updateUserRq, long timeout) throws RestClientException {
        return updateUserWithOutPermissions(id, updateUserRq).get(timeout);
    }

    /**
     * Запрос обновления основных полей пользователя (private api) асинхронно
     * POST /auth/v1/private/user/{id}/update
     *
     * @param id Идентификатор пользователя (required)
     * @param updateUserRq Тело запроса обновления данных пользователя (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> updateUserWithOutPermissions(Long id, UpdateUserRq updateUserRq) throws RestClientException {
        return new ClientRestResult<>(updateUserWithOutPermissionsInternal(id, updateUserRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> updateUserWithOutPermissionsInternal(Long id, UpdateUserRq updateUserRq) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "updateUserWithOutPermissions"));
        if (updateUserRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "updateUserRq", "updateUserWithOutPermissions"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/auth/v1/private/user/{id}/update")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(updateUserRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }
    private String cutComments(String path) {
        return path.split("#", 2)[0];
    }

    private void addPageableParams(MicroServiceURIBuilder builder, Pageable pageable) {
        if (pageable != null) {
            builder.param("page", pageable.getPageNumber());
            builder.param("size", pageable.getPageSize());
            Sort sort = pageable.getSort();
            if (sort != null) {
                List<String> sortParams = new ArrayList<>();
                for (Sort.Order next : sort) {
                    sortParams.add(next.getProperty());
                }
                sortParams.add(sort.getOrderFor(sortParams.get(0)).getDirection().name());
                builder.param("sort", String.join(",", sortParams));
            }
        }
    }

    private void processStatusCodeErrors(Exception e) throws RestClientException {
            HttpStatus statusCode = RestUtils.getStatusCode(e);
            if (statusCode != null) {
                switch (statusCode) {
                    case INTERNAL_SERVER_ERROR:
                        throw new RestClientException(String.format(STATUS_CODE_TEMPLATE, HttpStatus.INTERNAL_SERVER_ERROR.toString()));
                    case CONFLICT:
                        throw new EntityExistsException();
                    case NOT_FOUND:
                        throw new NotFoundException();
                }
            }
            throw new RestClientException(e.toString());
    }
}
